// =======================================================
// * OutputManager
// =======================================================

package reflaxe.output;

#if (macro || reflaxe_runtime)

import haxe.io.BytesBuffer;
import haxe.macro.Context;

import reflaxe.BaseCompiler;

// ---

using Lambda;

using reflaxe.helpers.BaseTypeHelper;
using reflaxe.helpers.NullHelper;

typedef OutputMetadata = {
	/**
		The version of the output metadata format for Reflaxe.
	**/
	version: Int,

	/**
		This value is incremented every time Reflaxe compiles a target.
		Checking if this value has changed can check if Reflaxe has compiled.
	**/
	id: Int,

	/**
		If `true`, the most recent compilation was performed with cached modules.
	**/
	wasCached: Bool,

	/**
		A list of file paths to all the files generated by the Reflaxe target.
	**/
	filesGenerated: Array<String>,
}

/**
	Class containing all code related to generating the
	output files from the compiled classes.
**/
class OutputManager {
	// -------------------------------------------------------
	// constants
	public final GENERATED_LIST_FILENAME = "_GeneratedFiles.json";

	// -------------------------------------------------------
	// fields
	public var compiler(default, null): BaseCompiler;
	public var outputDir(default, null): Null<String> = null;

	var outputFiles: Array<String> = [];
	var outputMetadata: Null<OutputMetadata> = null;

	/**
		If any file is modified, created, or deleted, this should be set to `true`.
	**/
	var changed = false;

	/**
		The loaded count value from _GeneratedFiles.txt.
	**/
	var lastId = -1;

	// -------------------------------------------------------
	// getters
	var options(get, never): BaseCompilerOptions;
	function get_options(): BaseCompilerOptions return compiler.options;

	// -------------------------------------------------------
	// new
	public function new(compiler: BaseCompiler) {
		this.compiler = compiler;
	}

	// -------------------------------------------------------
	// joinPaths
	static function joinPaths(path1: String, path2: String): String {
		return haxe.io.Path.join([path1, path2]);
	}

	// -------------------------------------------------------
	// setOutputDir
	public function setOutputDir(outputDir: String) {
		this.outputDir = outputDir;
		checkForOldFiles();
	}

	/**
		Old output file management.
	**/
	function checkForOldFiles() {
		if(shouldDeleteOldOutput()) {
			outputMetadata = generatedFilesList();
			lastId = outputMetadata.id;
		}
	}

	function shouldDeleteOldOutput() {
		return options.fileOutputType != SingleFile && options.deleteOldOutput;
	}

	function generatedFilesList(): OutputMetadata {
		final path = generatedFilesPath();
		if(sys.FileSystem.exists(path)) {
			return try {
				(haxe.Json.parse(sys.io.File.getContent(path)) : OutputMetadata);
			} catch(_) {
				defaultGeneratedData();
			}
		}
		return defaultGeneratedData();
	}

	function defaultGeneratedData(): OutputMetadata {
		return {
			version: 1,
			id: 0,
			wasCached: false,
			filesGenerated: []
		};
	}

	function generatedFilesPath() {
		return joinPaths(outputDir.or(""), GENERATED_LIST_FILENAME);
	}

	function ensureOutputDirExists() {
		if(outputDir != null && !sys.FileSystem.exists(outputDir)) {
			sys.FileSystem.createDirectory(outputDir);
		}
	}

	/**
		Generates the output files.
	**/
	public function generateFiles() {
		switch(options.fileOutputType) {
			case Manual: {
				compiler.generateFilesManually();
			}
			case SingleFile: {
				generateSingleFile();
			}
			case FilePerModule: {
				generateFilePerModule();
			}
			case FilePerClass: {
				generateFilePerClass();
			}
		}

		for(path => content in compiler.extraFiles) {
			final keys = [];
			for(priority => cpp in content) {
				if(StringTools.trim(cpp).length > 0) {
					keys.push(priority);
				}
			}

			keys.sort((a, b) -> a - b);

			var result = [];
			for(k in keys) {
				final c = content.get(k);
				if(c != null && StringTools.trim(c).length > 0) {
					result.push(c);
				}
			}

			saveFile(path, result.join("\n\n"));
		}

		if(shouldDeleteOldOutput()) {
			deleteOldOutputFiles();
			recordAllOutputMetadata();
		}
	}

	/**
		Generates a single file.

		This should be able to take no path, a file path, OR a directory path.
	**/
	function generateSingleFile() {
		var filePath = {
			// If output exists and ends with file-extension, it is a direct path
			if(outputDir != null && (options.fileOutputExtension.length == 0 || StringTools.endsWith(outputDir, options.fileOutputExtension))) {
				final file: String = haxe.io.Path.withoutDirectory(outputDir);
				outputDir = haxe.io.Path.directory(outputDir);
				file;
			}
			
			// Otherwise, it is a directory and use the default file name
			else {
				options.defaultOutputFilename;
			}
		}

		if(outputDir != null && outputDir.length > 0) {
			ensureOutputDirExists();
		}

		final arr = [];
		for(o in compiler.generateOutputIterator()) {
			arr.push(o.data);
		}
		saveFile(filePath, joinStringOrBytes(arr));
	}

	function generateFilePerModule() {
		ensureOutputDirExists();

		final files: Map<String, Array<StringOrBytes>> = [];
		for(c in compiler.generateOutputIterator()) {
			final mid = c.baseType.moduleId();
			final filename = overrideFileName(mid, c);
			if(!files.exists(filename)) {
				files[filename] = [];
			}
			final f = files[filename];
			if(f != null) {
				f.push(c.data);
			}
		}

		for(moduleId => outputList in files) {
			saveFile(getFileName(moduleId), joinStringOrBytes(outputList));
		}
	}

	static function joinStringOrBytes(list: Array<StringOrBytes>): StringOrBytes {
		final strings = [];
		final bytes = [];
		for(o in list) {
			switch(o.data()) {
				case String(s): strings.push(s);
				case Bytes(b): bytes.push(b);
			}
		}

		if(strings.length > 0 && bytes.length > 0) {
			throw "Cannot mix String and Bytes outputs for join.";
		}

		return if(strings.length > 0) {
			strings.join("\n\n");
		} else if(bytes.length > 0) {
			final bb = new BytesBuffer();
			for(b in bytes) bb.add(b);
			bb.getBytes();
		} else {
			"";
		}
	}

	function generateFilePerClass() {
		ensureOutputDirExists();
		for(c in compiler.generateOutputIterator()) {
			final filename = overrideFileName(c.baseType.globalName(), c);
			saveFile(getFileName(filename), c.data);
		}
	}

	inline function overrideFileName(defaultName: String, o: {
		var overrideFileName(default, null): Null<String>;
		var overrideDirectory(default, null): Null<String>;
	}) {
		return (o.overrideDirectory != null ? o.overrideDirectory + "/" : "") + (o.overrideFileName ?? defaultName);
	}

	function getFileName(filename: String): String {
		return filename + options.fileOutputExtension;
	}

	/**
		Internal helper function for saving content to a path
		relative to the output folder.
	**/
	public function saveFile(path: String, content: StringOrBytes) {
		// Get full path
		final p = if(haxe.io.Path.isAbsolute(path)) {
			path;
		} else if(outputDir != null) {
			joinPaths(outputDir, path);
		} else {
			path;
		}

		// Ensure directories exist
		final dir = haxe.io.Path.directory(p);
		if(!sys.FileSystem.exists(dir)) {
			sys.FileSystem.createDirectory(dir);
		}

		// Save file
		saveFileImpl(p, content);
	}

	function saveFileImpl(path: String, content: StringOrBytes) {
		// Do not save anything if the file already exists and has same content
		if(!sys.FileSystem.exists(path) || !content.matchesFile(path)) {
			content.save(path);
			changed = true;
		}
		if(shouldDeleteOldOutput()) {
			recordOutputFile(path);
		}
	}

	/**
		Records a path for a file that was generated.
		Ensures it will not be deleted when the rest of the old source files are removed.
	**/
	function recordOutputFile(path: String) {
		if(outputDir == null) return;
		final dir = StringTools.endsWith(outputDir, "/") ? outputDir : (outputDir + "/");
		final outputFilePath = StringTools.replace(path, dir, "");
		outputFiles.push(outputFilePath);

		if(outputMetadata != null) {
			#if !reflaxe.disallow_build_cache_check
			if(ReflectCompiler.isCachedRebuild) {
				// Don't modify `filesGenerated` if we are cache rebuilding.
			} else
			#end

			// -------------------------------------------------------
			// We overwrote this file if it existed, so we can
			// remove it from old files we're planning to delete.
			if(outputMetadata.filesGenerated.contains(outputFilePath)) {
				outputMetadata.filesGenerated.remove(outputFilePath);
			}
		}
	}

	/**
		We've removed elements from this array if we saved
		a new file with the same path, so we can safely assume
		all the remaining elements are old file paths we
		want to delete.
	**/
	function deleteOldOutputFiles() {
		#if !reflaxe.disallow_build_cache_check
		if(ReflectCompiler.isCachedRebuild) {
			return;
		}
		#end

		if(outputMetadata != null && outputDir != null) {
			for(file in outputMetadata.filesGenerated) {
				final filePath = joinPaths(outputDir, file);
				if(sys.FileSystem.exists(filePath)) {
					try {
						sys.FileSystem.deleteFile(filePath);
					} catch(e) {
						#if eval
						Context.warning('Could not delete file at "$filePath".\n$e', Context.currentPos());
						#end
					}
				}
			}
		}
	}

	function recordAllOutputMetadata() {
		if(!changed) {
			Sys.println("No files updated.");
		}

		if(outputFiles.length <= 0) {
			return;
		}

		final outputMetadata: OutputMetadata = {
			version: 1,
			id: #if !reflaxe.dont_output_metadata_id lastId + 1 #else 0 #end,
			wasCached: #if !reflaxe.disallow_build_cache_check ReflectCompiler.isCachedRebuild #else false #end,
			filesGenerated: [],
		};

		// -------------------------------------------------------
		// If this is a cache build, we cannot delete old files.
		// Instead add this to the list of files generated if it
		// doesn't exist.
		#if !reflaxe.disallow_build_cache_check
		if(ReflectCompiler.isCachedRebuild) {
			for(outputFile in outputFiles) {
				if(!outputMetadata.filesGenerated.contains(outputFile)) {
					outputMetadata.filesGenerated.push(outputFile);
				}
			}
			Sys.println("Only recompiled " + outputFiles.length + " file" + (outputFiles.length != 1 ? "s" : "") + ".");
		} else
		#end
		{
			outputMetadata.filesGenerated = outputFiles;
		}

		sys.io.File.saveContent(generatedFilesPath(), haxe.Json.stringify(outputMetadata, "\t"));
	}
}

#end
